24,25c24,25
<            npara.append(int(3**i))
<            index_para=torch.cat((index_para,torch.ones((npara[i]),dtype=torch.long)*i))
---
>             npara.append(int(3**i))
>             index_para=torch.cat((index_para,torch.ones((npara[i]),dtype=torch.long)*i))
74,81c74,75
< 
<     def forward(self,cart,atom_index,local_species,neigh_species):
<         """
<         # input cart: coordinates (nall,3)
<         # input atom_index12(2*maxneigh): store the index of neighbour atoms for each central atom
<         # input shift_values: coordinates shift values (unit cell) (maxneigh,3)
<         # Tensor: radial
<         # angular: orbital form
---
>     
>     def forward(self,cart,neigh_list,shifts,species):
83,85c77,86
<         nlocal=local_species.shape[0]
<         selected_cart = cart.index_select(0, atom_index.view(-1)).view(2, -1, 3)
<         dist_vec = selected_cart[0] - selected_cart[1]
---
>         # input cart: coordinates (nbatch*numatom,3)
>         # input shifts: coordinates shift values (unit cell)
>         # input numatoms: number of atoms for each configuration
>         # atom_index: neighbour list indice
>         # species: indice for element of each atom
>         """ 
>         numatom=cart.shape[0]
>         neigh_species=species.index_select(0,neigh_list[1])
>         selected_cart = cart.index_select(0, neigh_list.view(-1)).view(2, -1, 3)
>         dist_vec = selected_cart[0] - selected_cart[1]-shifts
88,95c89,103
<         orbital = torch.einsum("ji,ik -> ijk",self.angular(dist_vec,self.cutoff_cosine(distances)),\
<         self.gaussian(distances,neigh_species))
<         orb_coeff=self.params.index_select(0,neigh_species)
<         worbital=torch.einsum("ijk,ik ->ijk", orbital,orb_coeff)
<         sum_worbital=torch.zeros((nlocal,orbital.shape[1],self.rs.shape[1]),dtype=orb_coeff.dtype,device=orb_coeff.device)
<         sum_worbital=torch.index_add(sum_worbital,0,atom_index[0],worbital)
<         expandpara=self.hyper[0].index_select(0,self.index_para)
<         hyper_worbital=torch.einsum("ijk,jkm -> ijm", sum_worbital,expandpara)
---
>         orbital = torch.einsum("ji,ik -> ijk",self.angular(dist_vec,self.cutoff_cosine(distances)),self.gaussian(distances,neigh_species))
>         orb_coeff=self.params.index_select(0,species)
>         density=self.obtain_orb_coeff(0,numatom,orbital,neigh_list,orb_coeff)
>         for ioc_loop, (_, m) in enumerate(self.ocmod.items()):
>             orb_coeff += m(density,species)
>             density = self.obtain_orb_coeff(ioc_loop+1,numatom,orbital,neigh_list,orb_coeff)
>         return density
> 
>     def obtain_orb_coeff(self,iteration:int,numatom:int,orbital,neigh_list,orb_coeff):
>         expandpara=orb_coeff.index_select(0,neigh_list[1])
>         worbital=torch.einsum("ijk,ik ->ijk", orbital,expandpara)
>         sum_worbital=torch.zeros((numatom,orbital.shape[1],self.rs.shape[1]),dtype=orb_coeff.dtype,device=orb_coeff.device)
>         sum_worbital=torch.index_add(sum_worbital,0,neigh_list[0],worbital)
>         expandpara=self.hyper[iteration].index_select(0,self.index_para)
>         hyper_worbital=torch.einsum("ijk,jkm ->ijm",sum_worbital,expandpara)
96a105
> 
